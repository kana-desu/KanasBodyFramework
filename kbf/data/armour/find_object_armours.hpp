#pragma once

#include <reframework/API.hpp>

#include <kbf/data/armour/armour_list.hpp>
#include <kbf/util/re_engine/reinvoke.hpp>
#include <kbf/util/re_engine/dump_transform_tree.hpp>

#include <algorithm>

using REApi = reframework::API;

namespace kbf {

    inline std::vector<std::string> findArmourObjectsInTransformTree(REApi::ManagedObject* transform) {
        // via.Transform:find(System.String) is really unreliable, so do a manual search of the first layer of the transform tree instead.
        // Typically, find armours under Root > AutoGenerated Types (3) > AutoGeneratedTypes(0) in reframework obj viewer

        std::vector<std::string> names = dumpTransformTree(transform, 1, 100);

        // Filter names by those which start with ch...
        std::vector<std::string> armourNames;
        std::copy_if(names.begin(), names.end(), std::back_inserter(armourNames),
            [](const std::string& name) {
                return name.rfind("ch", 0) == 0; // starts with "ch"
            }
		);

        return armourNames;
    }

    static inline ArmourPieceFlags scanArmourList(
        const std::vector<std::string> objects, 
        char normalizer,
        std::array<ArmourSet, 6>& out
    ) {
        ArmourPieceFlags foundFlags = ArmourPieceFlagBits::APF_NONE;

        for (const std::string& armourId : objects) {
            if (armourId[3] != '2' && armourId[3] != '3') continue;

            ArmourPiece piece = ArmourPiece::AP_SET;
            ArmourPieceFlagBits pieceFlag = ArmourPieceFlagBits::APF_NONE;
            switch (armourId.back()) {
            case '1': piece = ArmourPiece::AP_ARMS;    pieceFlag = APF_ARMS; break;
            case '2': piece = ArmourPiece::AP_BODY;    pieceFlag = APF_BODY; break;
            case '3': piece = ArmourPiece::AP_HELM;    pieceFlag = APF_HELM; break;
            case '4': piece = ArmourPiece::AP_LEGS;    pieceFlag = APF_LEGS; break;
            case '5': piece = ArmourPiece::AP_COIL;    pieceFlag = APF_COIL; break;
			case '6': piece = ArmourPiece::AP_SLINGER; pieceFlag = APF_SLINGER; break;
            default: continue; // Invalid piece
            }

            std::string normalizedId = armourId;
            // ids stored in the look up tabe are all female... i.e. ch03_XXX_XXXX
            normalizedId[3] = normalizer;

            ArmourSet set = ArmourList::getArmourSetFromId(normalizedId);
            if (set != ArmourList::DefaultArmourSet()) {
                // Players in multiplayer also have loooaaads of other objects present, but the first seems to always be the right one.
				size_t index = static_cast<size_t>(piece - 1);
                if (out[index] != ArmourList::DefaultArmourSet()) {
					//DEBUG_STACK.push(std::format("Found collision with {} -> {}", out[index].name, set.name), DebugStack::Color::WARNING);
                    continue;
				}

                out[static_cast<int>(piece - 1)] = set;
                foundFlags |= pieceFlag;
            }
        }

        return foundFlags;
    }

    inline std::array<ArmourSet, 6> findAllArmoursInObjectFromList(
        REApi::ManagedObject* transform,
        bool female
    ) {
        // Array of 6 ArmourList::DefaultArmourSet();
        std::array<ArmourSet, 6> foundArmours{};
        foundArmours.fill(ArmourList::DefaultArmourSet());

        std::vector<std::string> armours = findArmourObjectsInTransformTree(transform);
		ArmourPieceFlags foundFlags = scanArmourList(armours, '3', foundArmours);

        // If normal search fails, try finding any full sets. 
        if (foundFlags == ArmourPieceFlagBits::APF_NONE) {
			foundFlags = scanArmourList(armours, '2', foundArmours);
        }

        // If only the body is populated, we have a full set, populate all the rest.
        if (foundFlags == ArmourPieceFlagBits::APF_BODY) {
			const auto& bodySet = foundArmours[static_cast<int>(ArmourPiece::AP_BODY - 1)];
			foundArmours[static_cast<int>(ArmourPiece::AP_HELM - 1)] = bodySet;
			foundArmours[static_cast<int>(ArmourPiece::AP_ARMS - 1)] = bodySet;
			foundArmours[static_cast<int>(ArmourPiece::AP_COIL - 1)] = bodySet;
			foundArmours[static_cast<int>(ArmourPiece::AP_LEGS - 1)] = bodySet;
        }

        return foundArmours;
    }

    inline ArmourSet findFirstArmourInObjectFromList(
        REApi::ManagedObject* transform,
        const bool female,
        ArmourPiece piece
    ) {
		if (piece == ArmourPiece::AP_SET) return ArmourList::DefaultArmourSet();

        std::vector<std::string> armours = findArmourObjectsInTransformTree(transform);

        std::string lastChar = "";
        switch (piece) {
		case ArmourPiece::AP_HELM:    lastChar = "3"; break;
		case ArmourPiece::AP_BODY:    lastChar = "2"; break;
		case ArmourPiece::AP_ARMS:    lastChar = "1"; break;
		case ArmourPiece::AP_COIL:    lastChar = "5"; break;
		case ArmourPiece::AP_LEGS:    lastChar = "4"; break; 
		case ArmourPiece::AP_SLINGER: lastChar = "6"; break;
        }
		const char& lastCharCStr = lastChar.back();

        for (const std::string& armourId : armours) {
			if (armourId[3] != '2' && armourId[3] != '3') continue; // Not a male or female armour piece
            
            // Armour set must end in '2' for body, '4' for legs
			if (armourId.back() != lastCharCStr) continue;

            std::string normalizedId = armourId;
            // ids stored in the look up tabe are all female... i.e. ch03_XXX_XXXX
			normalizedId[3] = '3';

            ArmourSet set = ArmourList::getArmourSetFromId(normalizedId);
            if (set != ArmourList::DefaultArmourSet()) return set;
		}

        return ArmourList::DefaultArmourSet();
    }

    inline ArmourSet findFirstNPCArmourInObjectFromList(
        REApi::ManagedObject* transform
    ) {
        if (transform == nullptr) return ArmourList::DefaultArmourSet();

        std::vector<std::string> armours = findArmourObjectsInTransformTree(transform);
        for (const std::string& armourId : armours) {
            if (armourId[3] == '4') {
                ArmourSet set = ArmourList::getArmourSetFromId(armourId);
                if (set != ArmourList::DefaultArmourSet()) return set;
            }
        }

        return ArmourList::DefaultArmourSet();
    }

	inline std::vector<std::string> findObjectArmoursExhaustive(REApi::ManagedObject* transform) {
		std::vector<std::string> foundArmours;

        for (int a = 2; a <= 4; ++a) {           // XX
            for (int b = 0; b <= 400; ++b) {     // XXX
                for (int c = 0; c <= 400; ++c) { // XXXX
                    // Format the string with zero-padding
                    char buf[32];
                    std::snprintf(buf, sizeof(buf), "ch%02d_%03d_%04d", a, b, c);

                    // Convert to managed string
                    REApi::ManagedObject* param = REApi::get()->create_managed_string_normal(buf);

                    // Call the "find(System.String)" method
                    bool found = REInvoke<bool>(
                        transform,
                        "find(System.String)",
                        { (void*)param },
                        InvokeReturnType::BOOL
                    );

                    if (found) {
						foundArmours.push_back(buf);
                    }
                }
            }
        }

		return foundArmours;
	}

}